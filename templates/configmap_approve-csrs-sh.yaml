apiVersion: v1
kind: ConfigMap
metadata:
  name: approve-csrs-sh
  namespace: kube-system
data:
  approve-csrs.sh: |
    #!/bin/bash
    
    # Fetch list of CSRs
    CSR_LIST=$(curl -s --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/apis/certificates.k8s.io/v1/certificatesigningrequests)    

    # Filter list of CSRs for CSRs with status 'Pending' and return them as JSON array
    CSR_LIST=$(echo "$CSR_LIST" | jq -r '.items[] | select(.status == {})' | jq -s '.')
    
    CSR_LIST_LENGTH=$(echo "$CSR_LIST" | jq length)
    
    # If there are no CSRs, exit
    if (( CSR_LIST_LENGTH == 0 )); then
      echo "No CSRs found."
      exit 0
    fi        
    
    # Print CSR names
    echo "##############################################"
    echo "CSRs to approve:"
    echo "$CSR_LIST" | jq -r '.[].metadata.name'
    echo "##############################################"        
    
    # Iterate over list of CSRs and approve each one
    COUNTER=0
    while [ $COUNTER -le $((CSR_LIST_LENGTH - 1)) ]; do
      CSR=$(echo "$CSR_LIST" | jq -r ".[$COUNTER]")
      CSR_NAME=$(echo "$CSR" | jq -r '.metadata.name')

      # Ensure spec.username field is of the form 'system:node:<nodeName>'
      if ! jq -e '.spec.username | select(. == "system:node:*")' "$CSR" > /dev/null; then
        echo "The CSR doesn't have a field .spec.username in the form of system:node:<nodeName>. Won't approve."
        return
      fi

      # Ensure spec.groups array contains 'system:nodes'
      if ! jq -e '.spec.groups[] | select(. == "system:nodes")' "$CSR" > /dev/null; then
        echo "The CSR doesn't contain system:nodes in spec.groups array. Won't approve."
        return
      fi

      # Ensure spec.usages contains 'server auth'
      if ! jq -e '.spec.usages[] | select(. == "server auth")' "$CSR" > /dev/null; then
        echo "The CSR doesn't contain 'server auth' in spec.usages array. Won't approve."
        return
      fi

      # Ensure spec.usages optionally only contains 'digital signature' or 'key encipherment'
      allowed_elements=("server auth" "digital signature" "key encipherment")
      invalid_elements=$(jq -r '.spec.usages[]' "$CSR" | grep -v -F -x "${allowed_elements[@]}")

      if [[ -n $invalid_elements ]]; then
        echo "The CSR contains invalid elements in spec.usages array: $invalid_elements"
        echo "Won't approve."
        return
      fi

      # Read 'Subject Alternative Name' field of x509 certificate into array
      IFS=',' read -r -a SUBJECT_ALTERNATIVE_NAME_ARRAY <<< $(echo $CSR_LIST | jq -r '.[0].spec.request' | base64 -d | openssl req -text -noout | grep -A 1 "Subject Alternative Name" | sed -n '2p')
      SUBJECT_ALTERNATIVE_NAME_ARRAY_LENGTH=${#SUBJECT_ALTERNATIVE_NAME_ARRAY[@]}

      # Ensure 'Subject Alternative Name' field of x509 certificate only consists of DNS and IP Address
      if (( SUBJECT_ALTERNATIVE_NAME_ARRAY_LENGTH != 2 )); then
        echo "Invalid number of subject alternative names. Only 2 allowed. Won't approve."
        return
      fi

      for subjAltName in "${SUBJECT_ALTERNATIVE_NAME_ARRAY[@]}"; do
        IFS=':' read -r -a SPLIT_ARRAY <<< echo $subjAltName
        IP_ADDRESS_OF_NODE=""
        if [[ ${SPLIT_ARRAY[0]} == *"DNS"* ]] ; then
          # Ensure node exists in the cluster
          HTTP_CODE=$(curl -w '%{http_code}' -s -o /dev/null --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" -X GET "Content-Type: application/json" -H "Accept: application/json" https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/api/v1/nodes/${SPLIT_ARRAY[1]})
          if (( HTTP_CODE != 200 )); then
            echo "Cluster has no node ${SPLIT_ARRAY[1]}. Subject Alternative Name DNS invalid. Won't approve."
            return
          fi
          IP_ADDRESS_OF_NODE=$(curl -s --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" -X GET "Content-Type: application/json" -H "Accept: application/json" https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/api/v1/nodes/${SPLIT_ARRAY[1]} | jq -r '.status.addresses[0].address')
        elif [[ ${SPLIT_ARRAY[0]} == *"IP Address"* ]] ; then
          # Ensure IP address of CSR belongs to node
          if [[ "$IP_ADDRESS_OF_NODE" != "${SPLIT_ARRAY[1]}" ]]; then
            echo "Subject Alternative Name IP Address doesn't match IP address of node. Won't approve."
            return
        else
          echo "Subject Alternative Name contains invalid element. Won't approve."
          return
        fi
      done

      # Add apiVersion and kind to CSR
      CSR_WITH_API_VERSION=$(echo "$CSR" | jq -r ". += { \"apiVersion\": \"certificates.k8s.io/v1\"}")
      CSR_WITH_KIND=$(echo "$CSR_WITH_API_VERSION" | jq -r ". += { \"kind\": \"CertificateSigningRequest\"}")

      # Add approval condition to CSR
      CSR_WITH_APPROVAL_CONDITION=$(echo "$CSR_WITH_KIND" | jq -r ".status.conditions += [{\"type\": \"Approved\", \"status\": \"True\", \"lastTransitionTime\": \"$(date +%FT%TZ)\", \"message\": \"Approved by kubelet-csr-approver\"}]")

      echo "##############################################"
      echo "Approving CSR: $CSR_NAME"
      HTTP_CODE=$(curl -w '%{http_code}' -s -o /dev/null --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" -X PUT -d "$(echo "$CSR_WITH_APPROVAL_CONDITION")" -H "Content-Type: application/json" -H "Accept: application/json" https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/apis/certificates.k8s.io/v1/certificatesigningrequests/$CSR_NAME/approval)            

      echo "HTTP Response Code: $HTTP_CODE"
      echo "##############################################"
      COUNTER=$((COUNTER+1))
    done

    # Exit with success
    exit 0
